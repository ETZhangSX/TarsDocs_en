# Directory
> * [Intro](#chapter-1)
> * [Create HttpServer](#chapter-2)
> * [Service Deployment](#chapter-3)
> * [Develop guideline](#chapter-4)

## 1 <a id="chapter-1"></a>Intro

### tars-client

The PHP ability to call the tars service is provided in the tars-client, including:
* Call the instance of the remote service;
* Call stat info report
* Automatic failover

### tars-server

Tars-server provides the underlying server framework and supports the following features:

* High performance service based on swoole1.x/2.x
* Support two protocol modes: tup protocol and tars stream
* Support three kinds of servers: http, TCP and timer
* Reporting, monitoring and log integration
* Tars platform publish support

### tars-config

The ability module to pull configuration files from the configuration service of the tars platform.

### tars-deploy

The module that packs the business code of tars-server.

### tars-extension

The PHP extension code that tars relies on

### tars-log

Modules of remote log writing by tars

### tars-monitor

The function modules of main dispatching report and characteristic report of tars

### tars-registry

The function module of tars for master addressing

### tars-report

The module of keeping alive service reporting by tars

### tars-utils

Modules of configuration file parsing by tars

### tars2php

The tool of automatic code generation can automatically generate server and client code.

## 2 <a id="chapter-2"></a>Create HttpServer

### Directory structure description

1. scripts: Store the scripts required by the business, such as tars2php.sh, which is responsible for generating the code required by the client according to the tars file
2. src: The directory of business logic mainly includes the following structure:
- component: The basic class of the storage controller is convenient for all controllers to share
- conf: The configuration required by the business is just a demo. If the configuration is distributed from the platform, it will be written to this folder by default;
- controller: C layer in MVC model
- servant: The client source code generated by tars2php, the directory name can be completely customized, and only needs to be distinguished during use;
- composer.json: Explain project dependencies
- index.php: The entry file of the whole service. The file name can be customized, but the private template on the platform must be changed. Add the entry field under the server
- services.php: Declare the base namespace name of the entire project
- tars: The TCP service depends on the example.tars file under this folder and the tars.client.proto.php file, which are necessary for generating code under the service. This will be explained in the following guide line.

## 3 <a id="chapter-3"></a>Service Deployment

Enter operation  = & gt; template

  The platform will provide a template for PHP named tars.tarsphp.default

  **You must first modify the execution path of PHP in it**

  There are two ways to ensure that HTTP server uses the correct template:

1. Create a new tars.tarsphp.http, inherit from tars.tarsphp.default. Add the following content:

```text
<tars> 
  <application>
      <client>
      </client>   
      <server>
        protocolName=http    
      </server>
  </application>
</tars>
```

Just add:

```text
  protocolName=http
```

2 The second way is to add this part of content in the private template:

```text
<tars> 
  <application>
      <client>
      </client>   
      <server>
        protocolName=http    
      </server>
  </application>
</tars>
```

Log in to the tars management platform and access the Operation - & gt; deployment.

```
App = match tars.proto.php in the tar folder below
Server Name = match tars.proto.php in the tar folder below
Server Type = tars_php
Template    = tars.tarsphp.default

NodeName    = tarsnode node ip
Port        = server port
Port Type   = TCP
Protocol    = NOT TARS
```  

Notice:
- Protocol type HTTP service must select non tars
- The number of threads corresponds to the number of processes in swoole
- The maximum number of connections, maximum queue length and queue timeout are not valid for PHP services

## 4 <a id="chapter-4"></a> Develop Guideline

Basic steps:
- Create a new directory structure, and fix it to scripts, src, and tars
- Create a new directory under src and copy the component and controller folders in example
- Create composer.json, content as:

```text
{   
  "name" : "tars-http-server-demo",   
  "description": "tars http server",   
  "require": 
  {       
    "phptars/tars-server": "~0.2",       
    "phptars/tars-deploy": "~0.1",       
    "phptars/tars2php": "~0.1",       
    "phptars/tars-log": "~0.1",       
    "ext-zip" : ">=0.0.1"   
  },   
  "autoload": 
  {       
    "psr-4": 
    {           
      "HttpServer\\" : "./"​       
    }   
  },   
  "minimum-stability": "stable",   
  "scripts" : 
  {       
    "deploy" : "\\Tars\\deploy\\Deploy::run"   
  }
}

```

1. Create index.php in src, content as:

```text
<?
  phprequire_once(__DIR__."/vendor/autoload.php");
  ​use \Tars\cmd\Command;​
  //php tarsCmd.php  conf restart
  $config_path = $argv[1];
  $pos = strpos($config_path,"--config=");​
  $config_path = substr($config_path,$pos+9);​
  $cmd = strtolower($argv[2]);​
  $class = new Command($cmd,$config_path);
  $class->run();
```

This file is responsible for startup and entry loading

2. Create services.php, content as:

```text
  <?php    
    // 以namespace的方式,在psr4的框架下对代码进行加载    
    return [      
      'obj' => [          
        'namespaceName' => 'HttpServer\\',          
        'saveTarsConfigFileDir' => 'src/conf/', 
        //从tarsconfig拉下来的文件保存目录 默认src目录下的conf          
        'saveTarsConfigFileName' => [ '',], 
        //需要从tarsconfig拉下来的文件名 在web上配置          
        'monitorStoreConf' => [              
          //使用redis缓存主调上报信息              
          //'className' => Tars\monitor\cache\RedisStoreCache::class,              
          //'config' => [              
            // 'host' => '127.0.0.1',              
            // 'port' => 6379,              
            // 'password' => ':'              
            //],              
            //使用swoole_table缓存主调上报信息（默认）              
            'className' => Tars\monitor\cache\SwooleTableStoreCache::class,              
            'config' => [                  
              'size' => 40960              
              ]          
              ],          
              'registryStoreConf' => [              
                'className' => Tars\registry\RouteTable::class,              
                'config' => [                  
                  'size' => 200              
                  ]          
                  ],          
                  'protocolName' => 'http', 
                  //http, json, tars or other          
                  'serverType' => 'http', 
                  //http(no_tars default), websocket, tcp(tars default), udp      
                  ],  
                  ];
```

namespaceName为业务实际使用的namespaceName,必须与composer.json中的配置相互对应 monitorStoreConf为主调上报信息的存储配置

* className 为主调上报信息的存储实现类的类名，默认为 \Tars\monitor\cache\SwooleTableStoreCache::class 使用_swoole\_table_存储，_tars-monitor_中还提供了_redis_的存储方式，用户也可以自定义新的实现，但是必须实现 _\Tars\monitor\contract\StoreCacheInterface_ 接口
* config 为主调上报信息的存储实现类的配置信息，在实现类初始化时作为参数传入，默认对应_swoole\_table_的size

1. composer install,加载对应的依赖包
2. 在src下新建conf目录存储配置,默认为ENVConf.php
3. tars文件夹下面新建tars.proto.php文件, 里面需要包含对你服务本身的说明:

   ```text
   <?phpreturn array(   'appName' => 'PHPTest',   'serverName' => 'PHPHttpServer',   'objName' => 'obj',);
   ```

   这个名称要与在tars平台上面的名称完全一一对应。

4. 如果你只是试一试,那么首先在可以直接跳到第14步 如果你需要调用tars服务,请继续
5. 将隔壁tcp-server的hello.tars放入tars文件夹中,同时在tars文件夹下面新建tarsclient.proto.php文件:

   ```text
   <?phpreturn array(  'appName' => 'PHPTest',  'serverName' => 'PHPServer',  'objName' => 'obj',  'withServant' => false,//决定是服务端,还是客户端的自动生成  'tarsFiles' => array(      './example.tars'  ),  'dstPath' => '../src/servant',  'namespacePrefix' => 'HttpServer\servant',);
   ```

   APPName、serverName、objName 需要与tars平台上面申请的完全一致。withServant必须为false,同时指定tarsFiles的路径。 dstPath一般是`../src/?`,这里为`../src/servant`,这样生成的代码就会到这个文件夹。 namespacePrefix是对应代码的命名空间,这里是`HttpServer\servant`,这个与composer.json中的psr-4的名称也是相互对应的。

6. 执行scripts下面的tars2php.sh会在src/servant下面生成一个三级文件夹

   ```text
   cd ../tars/php ../src/vendor/phptars/tars2php/src/tars2php.php ./tarsclient.proto.php
   ```

   这里就是PHPTest/PHPServer/obj

   * classes文件夹 - 存放tars中的struct生成的文件
   * tars文件夹 - 存放tars文件
   * TestTafServiceServant.php - 实际的远程rpc调用文件

7. 在controller中增加对应的rpc调用代码,具体可参考代码中demo,或tars-client的用法说明
8. 完成代码开发后,在src目录下执行 composer run-script deploy 会自动进行代码打包
9. 将打包好的代码,上传到tars平台,并进行发布

